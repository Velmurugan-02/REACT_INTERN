UseMemo :
The useMemo Hook is a built-in React Hook that helps optimize performance by memoizing the result of a computation and reusing it unless its dependencies change. This prevents expensive computations from being re-executed unnecessarily during component re-renders.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Syntax :
1.const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
2.const memoizedValue = useMemo(() => {
  // expensive computation
  return result;
}, [dependencies]);


The first argument is a function that returns the computed value.
The second argument is an array of dependencies. When any of these dependencies change, the function gets re-evaluated.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.Optimizing Expensive Calculations
import React, { useState, useMemo } from "react";

function App() {
    const [number, setNumber] = useState(0);
    const squaredNum = useMemo(() => squareNum(number), [number]);
    const [counter, setCounter] = useState(0);
    const onChangeHandler = (e) => {
        setNumber(e.target.value);
    };
    const counterHander = () => {
        setCounter(counter + 1);
    };
    return (
        <div className="App">
            <h1>Welcome to Geeksforgeeks</h1>
            <input
                type="number"
                placeholder="Enter a number"
                value={number}
                onChange={onChangeHandler}
            ></input>

            <div>OUTPUT: {squaredNum}</div>
            <button onClick={counterHander}>Counter ++</button>
            <div>Counter : {counter}</div>
        </div>
    );
}
function squareNum(number) {
    console.log("Squaring will be done!");
    return Math.pow(number, 2);
}
export default App;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.Preventing Unnecessary Re-renders
import React, { useState, useMemo } from "react";

function Child({ userInfo }) {
    console.log("Child component rendered");
    return <p>User: {userInfo.name}</p>;
}
function Parent() {
    const [count, setCount] = useState(0);
    const userInfo = useMemo(() => ({ name: "GeeksforGeeks" }), []);
    return (
        <div>
            <p>Count: {count}</p>
            <Child userInfo={userInfo} />
            <button onClick={() => setCount(count + 1)}>Increment Count</button>
        </div>
    );
}
export default Parent;In this example

React, useState, and useMemo are imported for state management and optimization.
ChildComponent displays userInfo.name and logs renders.
ParentComponent memoizes userInfo to prevent re-creation.
Clicking the button updates count, re-rendering ParentComponent.
ParentComponent displays count, ChildComponent, and the button.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
You should use useMemo when :

You have expensive calculations that do not need to be re-executed unless certain dependencies change.
You are dealing with large data sets and need to optimize performance.
You want to prevent unnecessary re-renders of child components by ensuring stable references.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------